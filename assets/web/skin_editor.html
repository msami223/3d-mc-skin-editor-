<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft Skin Editor</title>
    <!-- Use Local Library -->
    <script src="skinview3d.bundle.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: system-ui, sans-serif;
            color: white;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        .top-bar {
            height: 60px;
            flex-shrink: 0;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .view-toggle {
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 12px;
            display: flex;
            gap: 8px;
        }

        .toggle-btn {
            border: none;
            background: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        .toggle-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .content {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            width: 100%;
        }

        #view2d,
        #view3d {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0;
            left: 0;
        }

        .hidden {
            display: none !important;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            /* NO background - must be transparent! */
        }

        #gridCanvas,
        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            border-radius: 4px;
        }

        #gridCanvas {
            z-index: 1;
        }

        #drawCanvas {
            z-index: 2;
            cursor: crosshair;
        }

        #viewer3d {
            outline: none;
        }

        .mode-pill {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            z-index: 50;
        }

        .controls-area {
            flex-shrink: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: env(safe-area-inset-bottom);
        }

        .color-bar {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            white-space: nowrap;
        }

        .colors-scroll {
            display: flex;
            gap: 12px;
            padding: 0 20px;
            align-items: center;
        }

        .swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
            transition: transform 0.2s, border-color 0.2s;
        }

        .swatch.active {
            transform: scale(1.2);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Rainbow Button */
        .swatch.rainbow {
            background: linear-gradient(135deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            position: relative;
        }

        .toolbar {
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .tool-group {
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 4px;
            border-radius: 12px;
        }

        .btn-tool {
            width: 44px;
            height: 44px;
            border: none;
            background: none;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .btn-tool.active {
            background: white;
            color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Pencil button shows selected color when active - override .active background */
        .btn-tool.active.pencil-colored {
            background: var(--pencil-color, white) !important;
            border: 2px solid white !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn-zoom {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            font-size: 18px;
            margin-left: 4px;
        }

        .btn-zoom:active {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-zoom.active {
            background: #4CAF50;
            color: white;
        }

        /* Modern Color Picker Modal */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .color-picker-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .picker-card {
            background: #1e1e1e;
            width: 300px;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .picker-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: white;
            font-weight: 600;
        }

        .picker-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 20px;
        }

        .sat-val-box {
            width: 100%;
            height: 200px;
            background: red;
            /* dynamic */
            border-radius: 10px;
            position: relative;
            margin-bottom: 15px;
            overflow: hidden;
            touch-action: none;
        }

        .sat-overlay-white {
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));
        }

        .sat-overlay-black {
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, #000, rgba(0, 0, 0, 0));
        }

        .picker-cursor {
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        .hue-slider {
            width: 100%;
            height: 20px;
            border-radius: 10px;
            background: linear-gradient(to right, red, #ff0, lime, cyan, blue, magenta, red);
            position: relative;
            margin-bottom: 20px;
            touch-action: none;
        }

        .hue-thumb {
            width: 20px;
            height: 24px;
            background: white;
            border-radius: 4px;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .picker-footer {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-color {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }

        .btn-select {
            flex: 1;
            background: #667eea;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 16px;
        }

        /* Debug Console - HIDDEN */
        #debugConsole {
            display: none !important;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="top-bar">
            <div class="view-toggle">
                <button class="toggle-btn active" id="tab2d" onclick="setMode('2d')">üé® 2D Canvas</button>
                <button class="toggle-btn" id="tab3d" onclick="setMode('3d')">üßä 3D Preview</button>
            </div>
        </div>

        <div class="content">
            <!-- 2D View -->
            <div id="view2d">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="gridCanvas"></canvas>
                    <canvas id="drawCanvas"></canvas>
                </div>
                <div class="mode-pill" id="modeLabel">‚úèÔ∏è Draw Mode</div>
            </div>

            <!-- 3D View -->
            <div id="view3d" class="hidden">
                <canvas id="viewer3d"></canvas>
                <div class="mode-pill">Use one finger to rotate</div>
            </div>
        </div>

        <div class="controls-area">
            <!-- Color Bar -->
            <div class="color-bar">
                <div class="colors-scroll" id="colorPalette">
                    <!-- Injected via JS -->
                </div>
            </div>

            <!-- Toolbar -->
            <div class="toolbar">
                <div class="tool-group">
                    <button class="btn-tool active" onclick="setTool('pencil')" id="btnPencil">‚úèÔ∏è</button>
                    <button class="btn-tool" onclick="setTool('eraser')" id="btnEraser">üßπ</button>
                    <button class="btn-tool rainbow-btn" onclick="openColorPicker()" id="btnRainbow">üåà</button>
                </div>

                <div style="display: flex; align-items: center;">
                    <button class="btn-zoom" onclick="zoomIdx(-1)">-</button>
                    <button class="btn-zoom" onclick="zoomIdx(1)">+</button>
                    <button class="btn-zoom" onclick="resetView()">‚äô</button>
                    <button class="btn-zoom" id="btnPan" onclick="togglePan()">‚úã</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="colorPickerModal" class="color-picker-modal">
        <div class="picker-card">
            <div class="picker-header">
                <span>Select Color</span>
                <button class="picker-close" onclick="closeColorPicker()">‚úï</button>
            </div>

            <div class="sat-val-box" id="svBox">
                <div class="sat-overlay-white"></div>
                <div class="sat-overlay-black"></div>
                <div class="picker-cursor" id="svCursor"></div>
            </div>

            <div class="hue-slider" id="hueSlider">
                <div class="hue-thumb" id="hueThumb"></div>
            </div>

            <div class="picker-footer">
                <div class="preview-color" id="pickerPreview"></div>
                <button class="btn-select" onclick="confirmColor()">Use Color</button>
            </div>
        </div>
    </div>

    <script>
        // Utils
        function log(msg) { console.log(msg); }
        window.onerror = function (msg, url, line) { console.error("JS Error: " + msg + " line " + line); };

        const SKIN_SIZE = 64;
        const DEFAULT_COLORS = ['#ef5350', '#ab47bc', '#5c6bc0', '#29b6f6', '#26a69a', '#9ccc65', '#ffca28', '#ffa726', '#8d6e63', '#212121', '#ffffff'];

        // --- Color Utils ---
        function hsvToRgb(h, s, v) {
            let r, g, b;
            let i = Math.floor(h * 6);
            let f = h * 6 - i;
            let p = v * (1 - s);
            let q = v * (1 - f * s);
            let t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsv(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) h = 0;
            else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, v };
        }

        // --- State ---
        let state = {
            mode: '2d',
            tool: 'pencil',
            color: '#ef5350',
            scale: 1.0,
            pan: { x: 0, y: 0 },
            isPanMode: false,
            pixelSize: 0,
            canvasSize: 0
        };

        let viewer;
        let gridCtx, drawCtx;
        let isDrawing = false;
        let isPanning = false;
        let lastPoint = null;
        let startPan = { x: 0, y: 0 };

        // Color Picker State
        let pickerState = {
            h: 0, s: 1, v: 1,
            isDraggingSV: false,
            isDraggingHue: false
        };

        const els = {
            gridCanvas: document.getElementById('gridCanvas'),
            drawCanvas: document.getElementById('drawCanvas'),
            canvasWrapper: document.getElementById('canvasWrapper'),
            colorPalette: document.getElementById('colorPalette'),
            modeLabel: document.getElementById('modeLabel'),
            btnPencil: document.getElementById('btnPencil'),
            btnEraser: document.getElementById('btnEraser'),
            modal: document.getElementById('colorPickerModal'),
            svBox: document.getElementById('svBox'),
            svCursor: document.getElementById('svCursor'),
            hueSlider: document.getElementById('hueSlider'),
            hueThumb: document.getElementById('hueThumb'),
            pickerPreview: document.getElementById('pickerPreview')
        };

        function init() {
            try {
                log('>>> init called');

                // Calculate canvas size from container
                const container = document.querySelector('.content');
                if (!container || container.clientWidth === 0) {
                    setTimeout(init, 100);
                    return;
                }

                const size = Math.min(container.offsetWidth, container.offsetHeight) - 40;
                state.canvasSize = size;
                state.pixelSize = size / SKIN_SIZE;

                els.canvasWrapper.style.width = size + 'px';
                els.canvasWrapper.style.height = size + 'px';

                els.gridCanvas.width = size;
                els.gridCanvas.height = size;
                els.drawCanvas.width = size;
                els.drawCanvas.height = size;

                gridCtx = els.gridCanvas.getContext('2d');
                drawCtx = els.drawCanvas.getContext('2d', { alpha: true });
                drawCtx.imageSmoothingEnabled = false;

                // CRITICAL: Clear draw canvas to ensure transparency
                drawCtx.clearRect(0, 0, size, size);
                log('Draw canvas cleared to transparent');

                log('Drawing initial grid');
                drawGrid();

                log('Rendering colors');
                renderColors();

                log('Calling updatePencilUI');
                updatePencilUI();

                els.drawCanvas.addEventListener('pointerdown', onDown);
                window.addEventListener('pointermove', onMove);
                window.addEventListener('pointerup', onUp);

                // Picker Events
                els.svBox.addEventListener('pointerdown', (e) => {
                    pickerState.isDraggingSV = true;
                    updateSV(e);
                });
                els.hueSlider.addEventListener('pointerdown', (e) => {
                    pickerState.isDraggingHue = true;
                    updateHue(e);
                });
                window.addEventListener('pointermove', (e) => {
                    if (pickerState.isDraggingSV) updateSV(e);
                    if (pickerState.isDraggingHue) updateHue(e);
                });
                window.addEventListener('pointerup', () => {
                    pickerState.isDraggingSV = false;
                    pickerState.isDraggingHue = false;
                });

                log('2D Canvas initialized');
                setTimeout(init3D, 500);
            } catch (e) {
                log('Init Error: ' + e.message);
            }
        }

        // --- Color Picker Logic ---
        function openColorPicker() {
            // Init from current color
            const rgb = hexToRgb(state.color) || { r: 255, g: 0, b: 0 };
            const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
            pickerState.h = hsv.h;
            pickerState.s = hsv.s;
            pickerState.v = hsv.v;

            updatePickerUI();
            els.modal.classList.add('visible');
        }

        function closeColorPicker() {
            els.modal.classList.remove('visible');
        }

        function confirmColor() {
            const rgb = hsvToRgb(pickerState.h, pickerState.s, pickerState.v);
            const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
            setColor(hex);
            closeColorPicker();
        }

        function updateSV(e) {
            const rect = els.svBox.getBoundingClientRect();
            let x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            let y = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));

            pickerState.s = x;
            pickerState.v = 1 - y;
            updatePickerUI();
        }

        function updateHue(e) {
            const rect = els.hueSlider.getBoundingClientRect();
            let x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            pickerState.h = x;
            updatePickerUI();
        }

        function updatePickerUI() {
            // SV background based on Hue
            const hColor = hsvToRgb(pickerState.h, 1, 1);
            els.svBox.style.backgroundColor = `rgb(${hColor.r}, ${hColor.g}, ${hColor.b})`;

            // SV Cursor
            els.svCursor.style.left = (pickerState.s * 100) + '%';
            els.svCursor.style.top = ((1 - pickerState.v) * 100) + '%';

            // Hue Thumb
            els.hueThumb.style.left = (pickerState.h * 100) + '%';

            // Result
            const rgb = hsvToRgb(pickerState.h, pickerState.s, pickerState.v);
            const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
            els.pickerPreview.style.backgroundColor = hex;
        }

        // --- App Logic ---

        function renderColors() {
            const html = DEFAULT_COLORS.map(c =>
                `<div class="swatch ${state.color === c ? 'active' : ''}" 
                  style="background: ${c}" 
                  onclick="setColor('${c}')"></div>`
            ).join('');
            els.colorPalette.innerHTML = html;
        }

        function setColor(color) {
            state.color = color;
            document.querySelectorAll('.swatch').forEach(el => {
                el.classList.remove('active');
                if (el.style.backgroundColor === color) {
                    el.classList.add('active');
                }
            });
            setTool('pencil'); // Switch to pencil when color picked
            updatePencilUI();
        }

        function updatePencilUI() {
            console.log('>>> updatePencilUI called');
            console.log('state.tool:', state.tool);
            console.log('state.color:', state.color);
            console.log('els.btnPencil:', els.btnPencil);

            if (state.tool === 'pencil') {
                console.log('Applying color to pencil button...');
                // Use CSS variable which is used by the .pencil-colored class
                els.btnPencil.style.setProperty('--pencil-color', state.color);
                els.btnPencil.classList.add('pencil-colored');
                console.log('After setting --pencil-color:', els.btnPencil.style.getPropertyValue('--pencil-color'));
                console.log('btnPencil classes:', els.btnPencil.className);

                // Determine contrast text color
                const rgb = hexToRgb(state.color) || { r: 255, g: 255, b: 255 };
                const yiq = ((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000;
                els.btnPencil.style.setProperty('color', (yiq >= 128) ? 'black' : 'white', 'important');
                console.log('Text color set to:', (yiq >= 128) ? 'black' : 'white');

            } else {
                console.log('Tool is not pencil, resetting styles');
                els.btnPencil.style.removeProperty('--pencil-color');
                els.btnPencil.style.removeProperty('color');
                els.btnPencil.classList.remove('pencil-colored');
            }
            console.log('<<< updatePencilUI complete');
        }




        function setTool(tool) {
            state.tool = tool;

            // Reset UI - use removeProperty to clear !important styles
            document.querySelectorAll('.btn-tool').forEach(b => {
                b.classList.remove('active', 'pencil-colored');
                b.style.removeProperty('background-color');
                b.style.removeProperty('color');
                b.style.removeProperty('border');
            });

            const activeBtn = tool === 'pencil' ? els.btnPencil : els.btnEraser;
            activeBtn.classList.add('active');

            if (tool === 'pencil') updatePencilUI();

            if (state.isPanMode) togglePan();
        }


        function setMode(mode) {
            state.mode = mode;
            document.getElementById('tab2d').classList.toggle('active', mode === '2d');
            document.getElementById('tab3d').classList.toggle('active', mode === '3d');
            document.getElementById('view2d').classList.toggle('hidden', mode !== '2d');
            document.getElementById('view3d').classList.toggle('hidden', mode !== '3d');

            if (mode === '3d') {
                if (viewer) {
                    const el = document.getElementById('view3d');
                    viewer.setSize(el.clientWidth, el.clientHeight);
                    update3DSkin();
                } else {
                    init3D();
                }
            }
        }

        function togglePan() {
            state.isPanMode = !state.isPanMode;
            document.getElementById('btnPan').classList.toggle('active', state.isPanMode);
            els.drawCanvas.style.cursor = state.isPanMode ? 'grab' : 'crosshair';
            els.modeLabel.innerText = state.isPanMode ? '‚úã Pan to Move' : '‚úèÔ∏è Draw Mode';
        }

        function drawGrid() {
            // IMPORTANT: Clear first, then ONLY draw grid lines - NO FILL!
            gridCtx.clearRect(0, 0, state.canvasSize, state.canvasSize);

            gridCtx.beginPath();
            gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)'; // Dark grey grid lines
            gridCtx.lineWidth = 1;

            for (let i = 0; i <= SKIN_SIZE; i++) {
                const pos = i * state.pixelSize;
                gridCtx.moveTo(pos, 0);
                gridCtx.lineTo(pos, state.canvasSize);
                gridCtx.moveTo(0, pos);
                gridCtx.lineTo(state.canvasSize, pos);
            }
            gridCtx.stroke();
        }

        function getCoords(e) {
            const rect = els.drawCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / (state.pixelSize * state.scale));
            const y = Math.floor((e.clientY - rect.top) / (state.pixelSize * state.scale));
            return { x, y };
        }

        function onDown(e) {
            if (state.mode !== '2d') return;

            if (state.isPanMode) {
                isPanning = true;
                startPan = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
                els.drawCanvas.style.cursor = 'grabbing';
                return;
            }

            const { x, y } = getCoords(e);
            isDrawing = true;
            paint(x, y);
            lastPoint = { x, y };
        }

        function onMove(e) {
            if (isPanning) {
                e.preventDefault();
                state.pan.x = e.clientX - startPan.x;
                state.pan.y = e.clientY - startPan.y;
                applyTransform();
                return;
            }

            if (!isDrawing) return;
            e.preventDefault();
            const { x, y } = getCoords(e);
            if (lastPoint) line(lastPoint.x, lastPoint.y, x, y);
            lastPoint = { x, y };
        }

        function onUp() {
            isDrawing = false;
            if (isPanning) {
                isPanning = false;
                if (state.isPanMode) els.drawCanvas.style.cursor = 'grab';
            }
            lastPoint = null;
            if (!isPanning && state.mode === '3d') update3DSkin();
        }

        function pickColor(x, y) {
            const px = Math.floor(x * state.pixelSize + state.pixelSize / 2);
            const py = Math.floor(y * state.pixelSize + state.pixelSize / 2);
            const p = drawCtx.getImageData(px, py, 1, 1).data;
            if (p[3] > 0) {
                const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                setColor(hex);
            }
        }

        function paint(x, y) {
            if (x < 0 || x >= SKIN_SIZE || y < 0 || y >= SKIN_SIZE) return;
            if (state.tool === 'eraser') {
                drawCtx.clearRect(x * state.pixelSize, y * state.pixelSize, state.pixelSize, state.pixelSize);
            } else if (state.tool === 'pencil') {
                drawCtx.fillStyle = state.color;
                drawCtx.fillRect(x * state.pixelSize, y * state.pixelSize, state.pixelSize, state.pixelSize);
            }
        }

        function line(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            while (true) {
                paint(x0, y0);
                if ((x0 === x1) && (y0 === y1)) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function zoomIdx(dir) {
            const levels = [0.5, 0.75, 1.0, 1.5, 2.0, 3.0, 4.0];
            let curr = state.scale;
            let idx = 2; // default
            let minDiff = 100;
            levels.forEach((l, i) => { if (Math.abs(l - curr) < minDiff) { minDiff = Math.abs(l - curr); idx = i; } });
            idx = Math.max(0, Math.min(levels.length - 1, idx + dir));
            state.scale = levels[idx];
            applyTransform();
        }

        function resetView() {
            state.scale = 1.0;
            state.pan = { x: 0, y: 0 };
            applyTransform();
        }

        function applyTransform() {
            els.canvasWrapper.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.scale})`;
        }

        function init3D() {
            log('>>> init3D called');

            log('Checking skinview3d library...');
            if (typeof skinview3d === 'undefined') {
                log("ERROR: skinview3d library not loaded!");
                return;
            }
            log('‚úì skinview3d library found');

            log('Getting viewer3d canvas element...');
            const el = document.getElementById('viewer3d');
            if (!el) {
                log('ERROR: viewer3d canvas not found!');
                return;
            }
            log('‚úì viewer3d canvas found');

            log('Getting view3d container...');
            const container = document.getElementById('view3d');
            if (!container) {
                log('ERROR: view3d container not found!');
                return;
            }
            const w = container.clientWidth || 300;
            const h = container.clientHeight || 400;
            log(`‚úì Container size: ${w}x${h}`);

            try {
                log(`Creating SkinViewer instance...`);
                viewer = new skinview3d.SkinViewer({
                    canvas: el,
                    width: w,
                    height: h,
                });
                log('‚úì SkinViewer created');

                log('Setting zoom to 0.8...');
                viewer.zoom = 0.8;
                log('‚úì Zoom set');

                log('Setting IdleAnimation...');
                viewer.animation = new skinview3d.IdleAnimation();
                log('‚úì Animation set');

                log('Calling update3DSkin...');
                update3DSkin();
                log('‚úì init3D complete');

            } catch (e) {
                log(`ERROR in init3D: ${e.name}: ${e.message}`);
                log(`Stack: ${e.stack}`);
            }
        }

        function update3DSkin() {
            log('>>> update3DSkin called');

            if (!viewer) {
                log('ERROR: viewer is null/undefined');
                return;
            }
            log('‚úì Viewer exists');

            try {
                log('Creating temp canvas...');
                const temp = document.createElement('canvas');
                temp.width = 64;
                temp.height = 64;
                log('‚úì Temp canvas created: 64x64');

                log('Getting 2d context...');
                const ctx = temp.getContext('2d');
                if (!ctx) {
                    log('ERROR: Failed to get 2d context');
                    return;
                }
                log('‚úì Context acquired');

                // Grey fallback color for Steve when no texture
                ctx.fillStyle = '#9E9E9E';
                ctx.fillRect(0, 0, 64, 64);

                // Draw ONLY user drawings/loaded skins (from drawCanvas)
                log(`Drawing user canvas (${state.canvasSize}x${state.canvasSize})...`);
                ctx.drawImage(els.drawCanvas, 0, 0, state.canvasSize, state.canvasSize, 0, 0, 64, 64);
                log('‚úì User drawing overlaid');

                log('Converting to data URL...');
                const dataUrl = temp.toDataURL();
                log(`‚úì Data URL created (length: ${dataUrl.length})`);

                log('Loading skin to viewer...');
                viewer.loadSkin(dataUrl);
                log('‚úì Skin loaded to viewer!');

            } catch (e) {
                log(`ERROR in update3DSkin: ${e.name}: ${e.message}`);
                log(`Stack: ${e.stack}`);
            }
        }


        // Import texture from gallery (called from Flutter)
        function loadSkin(base64Data) {
            try {
                log('Loading skin from gallery...');
                const img = new Image();
                img.onload = () => {
                    // Clear draw canvas and load skin onto it
                    drawCtx.clearRect(0, 0, state.canvasSize, state.canvasSize);

                    // Draw imported image to DRAW canvas
                    drawCtx.drawImage(img, 0, 0, state.canvasSize, state.canvasSize);
                    log('Skin loaded successfully');

                    // Update 3D
                    if (state.mode === '3d') {
                        update3DSkin();
                    }
                };
                img.onerror = () => {
                    console.error('Failed to load skin image');
                };
                img.src = 'data:image/png;base64,' + base64Data;
            } catch (e) {
                console.error('Error in loadSkin:', e);
            }
        }

        // Save current canvas as PNG with TRANSPARENT background
        function saveImage() {
            try {
                console.log('=== SAVE IMAGE DEBUG ===');
                console.log('drawCanvas size:', els.drawCanvas.width, 'x', els.drawCanvas.height);
                console.log('state.canvasSize:', state.canvasSize);

                // Check if drawCanvas has any content
                const drawData = drawCtx.getImageData(0, 0, els.drawCanvas.width, els.drawCanvas.height).data;
                let drawNonTransparentPixels = 0;
                for (let i = 3; i < drawData.length; i += 4) {
                    if (drawData[i] > 0) drawNonTransparentPixels++;
                }
                console.log('drawCanvas non-transparent pixels:', drawNonTransparentPixels);

                const temp = document.createElement('canvas');
                temp.width = 64;
                temp.height = 64;
                const ctx = temp.getContext('2d');

                // NO background fill - keep transparent

                // Draw ONLY user's drawing/loaded skin (from drawCanvas)
                ctx.drawImage(els.drawCanvas, 0, 0, state.canvasSize, state.canvasSize, 0, 0, 64, 64);

                // Check result
                const resultData = ctx.getImageData(0, 0, 64, 64).data;
                let resultNonTransparentPixels = 0;
                for (let i = 3; i < resultData.length; i += 4) {
                    if (resultData[i] > 0) resultNonTransparentPixels++;
                }
                console.log('RESULT non-transparent pixels:', resultNonTransparentPixels);
                console.log('=== END SAVE DEBUG ===');

                // Return as base64 PNG (PNG supports transparency)
                const dataUrl = temp.toDataURL('image/png');
                return dataUrl.split(',')[1]; // Return only base64 part
            } catch (e) {
                console.error('Error saving image:', e);
                return null;
            }
        }


        window.addEventListener('load', init);
        window.addEventListener('resize', () => { /* optional */ });

    </script>
</body>

</html>